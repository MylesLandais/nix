{ config
 , lib
 , pkgs
 , ...
 }:

with lib;

let
  cfg = config.services.sillytavern-container;
in
{
  options.services.sillytavern-container = {
    enable = mkEnableOption "SillyTavern service";

    dataDir = mkOption {
      type = types.str;
      default = "/var/lib/sillytavern";
      description = "Directory for SillyTavern data and config";
    };

    hostAddress = mkOption {
      type = types.str;
      default = "127.0.0.1";
      description = "Host address to bind to (0.0.0.0 for network access, 127.0.0.1 for localhost only)";
    };

    port = mkOption {
      type = types.port;
      default = 8765;
      description = "Port for SillyTavern to listen on (default: 8765 to avoid conflicts)";
    };

    openFirewall = mkOption {
      type = types.bool;
      default = false;
      description = "Open firewall for SillyTavern port";
    };

    enableMultiUser = mkOption {
      type = types.bool;
      default = false;
      description = "Enable multi-user account management";
    };

    user = mkOption {
      type = types.str;
      default = "sillytavern";
      description = "User to run SillyTavern as";
    };

    group = mkOption {
      type = types.str;
      default = "sillytavern";
      description = "Group to run SillyTavern as";
    };

    useContainer = mkOption {
      type = types.bool;
      default = true;
      description = "Use Podman container instead of systemd service";
    };

    imageTag = mkOption {
      type = types.str;
      default = "latest";
      description = "Docker image tag to use (consider pinning digest for production)";
    };
  };

  imports = [
    # Import the upstream module when not using container
    # Note: This causes infinite recursion if cfg is referenced in the condition
    # So we handle this differently
  ];

  config = mkIf cfg.enable (mkMerge [
    {
      # Disable upstream module to avoid conflicts
      services.sillytavern.enable = mkDefault false;
      # Create system user
      users.users.${cfg.user} = {
        isSystemUser = true;
        group = cfg.group;
        home = cfg.dataDir;
        createHome = true;
        extraGroups = [ "sillytavern-users" ];  # Add to shared group
      };

      users.groups.${cfg.group} = {};
      users.groups.sillytavern-users = {};  # Ensure shared group exists

      # Firewall
      networking.firewall = mkIf cfg.openFirewall {
        allowedTCPPorts = [ cfg.port ];
      };

      # Activation script for initial setup
      system.activationScripts.sillytavernSetup = ''
        # Create base directories
        mkdir -p ${cfg.dataDir}/{data,config,plugins,extensions}
        
        # Create the complete default-user directory structure that SillyTavern expects
        mkdir -p ${cfg.dataDir}/data/default-user
        mkdir -p ${cfg.dataDir}/data/default-user/"User Avatars"
        mkdir -p ${cfg.dataDir}/data/default-user/"User Icons"
        mkdir -p ${cfg.dataDir}/data/default-user/backgrounds
        mkdir -p ${cfg.dataDir}/data/default-user/characters
        mkdir -p ${cfg.dataDir}/data/default-user/chats
        mkdir -p ${cfg.dataDir}/data/default-user/groups
        mkdir -p ${cfg.dataDir}/data/default-user/group chats
        mkdir -p ${cfg.dataDir}/data/default-user/instruct
        mkdir -p ${cfg.dataDir}/data/default-user/context
        mkdir -p ${cfg.dataDir}/data/default-user/themes
        mkdir -p ${cfg.dataDir}/data/default-user/worlds
        mkdir -p ${cfg.dataDir}/data/default-user/personas
        mkdir -p ${cfg.dataDir}/data/default-user/movingUI
        mkdir -p ${cfg.dataDir}/data/default-user/QuickReplies
        mkdir -p ${cfg.dataDir}/data/default-user/OpenAI Settings
        mkdir -p ${cfg.dataDir}/data/default-user/NovelAI Settings
        mkdir -p ${cfg.dataDir}/data/default-user/KoboldAI Settings
        mkdir -p ${cfg.dataDir}/data/default-user/TextGen Settings
        
        # Create config with proper whitelist settings
        cat > ${cfg.dataDir}/config/config.yaml << EOF
# SillyTavern Configuration
# Generated by NixOS

# Data configuration
dataRoot: ./data

# Server settings
port: 8000
listen: false
listenAddress:
  ipv4: 0.0.0.0
  ipv6: '[::]'
protocol:
  ipv4: true
  ipv6: false

# Security settings - Fix whitelist to allow Podman network access
whitelistMode: true
enableForwardedWhitelist: true
whitelist:
  - ::1
  - 127.0.0.1
  - 10.88.0.1  # Podman network IP
  - 10.88.0.0/16  # Podman network range

# Basic authentication
basicAuthMode: false

# User accounts
${lib.optionalString cfg.enableMultiUser ''
enableUserAccounts: true
''}

# Performance settings
requestTimeout: 300
maxResponseLength: 16384

# Logging
minLogLevel: 1
enableConsoleLogging: true
enableFileLogging: false

# Other settings
autorun: true
sessionTimeout: -1
disableCsrfProtection: false
securityOverride: false
EOF
        # Set proper ownership - CRITICAL: Must be done AFTER all directories are created
        chown -R ${cfg.user}:${cfg.group} ${cfg.dataDir}
        
        # Set permissions to allow container user to write
        # The container runs as node user (typically UID 1000)
        # We need to make directories writable by the group or use broader permissions
        chmod -R u+rwX,g+rwX,o+rX ${cfg.dataDir}/data
        
        # Log what was created for debugging
        echo "SillyTavern setup completed. Directory structure:"
        ls -la ${cfg.dataDir}/data/
        echo ""
        echo "Default user directory:"
        ls -la ${cfg.dataDir}/data/default-user/ || echo "default-user directory check failed"
        echo ""
        echo "Permissions on data directory:"
        ls -ld ${cfg.dataDir}/data
        echo ""
        echo "Permissions on default-user directory:"
        ls -ld ${cfg.dataDir}/data/default-user
      '';
    }

    (mkIf cfg.useContainer {
      # Ensure Podman is available
      virtualisation.podman.enable = true;
      
      # OCI container configuration
      virtualisation.oci-containers.containers.sillytavern = {
        image = "ghcr.io/sillytavern/sillytavern:${cfg.imageTag}";
        ports = [ "${toString cfg.port}:8000" ];
        volumes = [
          "${cfg.dataDir}/data:/home/node/app/data"
          "${cfg.dataDir}/config:/home/node/app/config"
          "${cfg.dataDir}/plugins:/home/node/app/plugins"
          "${cfg.dataDir}/extensions:/home/node/app/public/scripts/extensions/third-party"
        ];
        environment = {
          NODE_ENV = "production";
        } // lib.optionalAttrs cfg.enableMultiUser {
          SILLYTAVEN_ENABLE_MULTIUSER = "true";
        };
        # Run as root in container to avoid permission issues
        # The application will drop privileges internally if needed
        user = "root:root";
        autoStart = true;
        # Extra options for better performance with multiple users
        extraOptions = [
          "--memory=2g"
          "--cpus=2"
          "--health-cmd=curl -f http://localhost:8000/ || exit 1"
          "--health-interval=30s"
          "--health-timeout=10s"
          "--health-retries=3"
          "--health-start-period=60s"
        ];
      };
      
      # Create systemd service for better management
      systemd.services.podman-sillytavern = {
        description = "SillyTavern Podman Container";
        after = [ "network-online.target" ];
        wants = [ "network-online.target" ];
        serviceConfig = {
          Type = "notify";
          Restart = "always";
          RestartSec = "10s";
        };
      };
    })

    (mkIf (!cfg.useContainer) {
      # systemd service configuration (using upstream module)
      # Note: We can't directly reference upstream options due to naming conflicts
      # This would require renaming our options or using a different approach
      # For now, we'll keep it simple and only support container mode
    })
  ]);
}